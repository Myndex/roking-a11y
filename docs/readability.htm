<!DOCTYPE html>
<html lang="en-US">
  <head>
    <title>Roking A11y Readability Evaluator</title>
    <style type="text/css">
      body {
        margin: auto;
        width: 80%;
      }

      blockquote {
        border-left: 0.25rem solid hsl(0, 0%, 90%);
        display: flex;
        margin: 0;
        padding: 1rem;
      }
      blockquote::before {
        background: hsl(0, 0%, 100%);
        color: hsl(0, 100%, 30%);
        content: "⚠";
        font-size: 2rem;
        margin: -0.5rem 0.5rem 0 0;
      }

      button {
        border-radius: 0.25rem;
        font-size: 1.5rem;
        margin: 0.2rem;
      }
      button:not([disabled]) {
        background-color: hsl(204, 100%, 60%);
        border: 1px solid hsl(204, 100%, 30%);
        color: hsl(0, 0%, 5%);
      }

      label {
        font-size: 1.5rem;
        margin-bottom: 0.5rem;
      }

      label,
      textarea {
        display: block;
        line-height: 1.2rem;
        width: 100%;
      }

      textarea {
        border: 1px solid hsl(204, 100%, 30%);
        font-size: 1rem;
        height: 24rem;
      }

      .score {
        background: hsl(204, 100%, 90%);
        border: 1px solid hsl(204, 100%, 30%);
        border-top: none;
        color: hsl(0, 0%, 5%);
        display: block;
        margin-bottom: 1rem;
        padding: 0.25rem 0.15rem;
        width: 100%;
      }
    </style>
  </head>
  <body>
    <main>
      <h1>Roking-A11y Readability Evaluator</h1>
      <p>
        The Readability utility calculates the Läsbarhetsindex for content.
      </p>
      <blockquote>
        The current version of the `Readability` object does not account for phrases that
        are not complete sentences, so some measure of caution should be used. For example,
        the phrase "Last Name" would have a Läsbarhetsindex score of 2, but the the phrase
        "Surname" would have a Läsbarhetsindex score of 101, even though its complexity would
        not _ordinarily_ be consider that much greater. I am currently working to determine
        how best to accommodate this.
      </blockquote>
      <p>
        Enter or paste the text to evaluate in the form below.
      </p>
      <p>
        <label for="textin">Text to evaluate</label>
        <textarea id="textin"></textarea>
        <span class="score">
          <span id="score-label">Score</span>: 
          <span aria-labelledby="score-label" id="score" role="status"></span>
        </span>
      </p>
      <p>
        <label for="lang">Language</label>
        <select id="lang"><option value="en">English</option></select>
      <p>
        <button type="button" onclick="calc();">Evaluate</button>
      </p>
    </main>
    <script>
function Readability(sample, wlen) { Object.defineProperty(this, 'avg', { get: getAvg, enumerable: true, }); Object.defineProperty(this, 'content', { set: setContent, enumerable: true, writeable: true, }); Object.defineProperty(this, 'lang', { set: setLang, enumerable: true, writeable: true, }); Object.defineProperty(this, 'languages', { get: getLangs, enumerable: true, writeable: false, }); this.wlong = wlen || 6; this.item = function getItem(index) { return self.parsed ? self.parsed[index] : null; }; this.score = function calculate(content) { /* parse the content if it's passed in */ if (content) { self.content = content; } return self; }; function getAvg() { if (self.parsed && self.parsed.length) { const scores = self.parsed.map(si => si.score); const sum = scores.reduce((ttl, score) => ttl + score); return Math.round(sum / self.parsed.length); } return 0; } function getLangs() { const langs = []; const keys = Object.keys(SIZES).sort(); let i = keys.length - 1; while (i > -1) { const code = keys[i]; const { name } = SIZES[code]; langs.unshift({ code, name }); i -= 1; } return langs; } function isPrimitive(value) { return /^(boolean|number|string)$/.test(typeof value); } function isElement(value) { return value && value.hasChildNodes; } function normalize(phrase) { const els = []; const tags = isElement(phrase) ? (phrase.body || phrase).getElementsByTagName('*') : null; if (isPrimitive(phrase)) { els.push(`${phrase}`); } else if (tags) { for (let c = tags.length - 1; c > -1; c -= 1) { els.unshift(tags.item(c).textContent.replace(/\s+/, ' ')); } } return els; } function parse(phrase) { const bites = phrase.split(' '); const words = bites.length; const longWords = bites.filter(word => word.length > self.wlong).length; const sentences = phrase.split(/[:.]/g).filter(el => !!el).length; const pcwords = words / (sentences || 1); const pclwords = (longWords * 100) / (words || 1); const score = !words || !sentences ? 0 : Math.round(pcwords + pclwords); return { longWords, phrase, score, sentences, words, }; } function setContent(data) { self.parsed = Array.isArray(data) ? data.map(el => parse(el)) : normalize(data).map(el => parse(el)); } function setLang(bcp47) { const ISO_PATTERN = /^([a-z]{2})(-[a-z]{2})?$/i; const langSubtag = (bcp47 || '').replace(ISO_PATTERN, (match, lang) => lang); if (Object.prototype.hasOwnProperty.call(SIZES, langSubtag)) { self.wlong = Math.round(SIZES[langSubtag].value); } } const self = this; const SIZES = { ar: { name: 'Arabic', l10n: 'العربية', value: 6.03 }, cs: { name: 'Czech', l10n: 'Český', value: 6.02 }, da: { name: 'Danish', l10n: 'Dansk', value: 5.48 }, de: { name: 'German', l10n: 'Deutsch', value: 6.03 }, el: { name: 'Greek', l10n: 'Ελληνικά', value: 6.47 }, en: { name: 'English', l10n: 'English', value: 6.08 }, es: { name: 'Spanish', l10n: 'Español', value: 5.71 }, et: { name: 'Estonian', l10n: 'Eesti', value: 7.3 }, eu: { name: 'Basque', l10n: 'Euskara', value: 6.51 }, fi: { name: 'Finnish', l10n: 'Suomi', value: 7.55 }, fr: { name: 'French', l10n: 'Français', value: 5.39 }, hr: { name: 'Croatian', l10n: 'Hrvatski Jezik', value: 5.58 }, hu: { name: 'Hungarian', l10n: 'Magyar', value: 6.48 }, is: { name: 'Icelandic', l10n: 'Íslenska', value: 5.97 }, it: { name: 'Italian', l10n: 'Italiano', value: 5.95 }, lt: { name: 'Lithuanian', l10n: 'Lietuvių Kalba', value: 6.85 }, lv: { name: 'Latvian', l10n: 'Latviešu Valoda', value: 7.14 }, nb: { name: 'Norwegian Bokmål', l10n: 'Norsk Bokmål', value: 5.37 }, nl: { name: 'Dutch', l10n: 'Nederlands', value: 6.48 }, nn: { name: 'Norwegian Nynorsk', l10n: 'Norsk Nynorsk', value: 5.37 }, no: { name: 'Norwegian', l10n: 'Norsk', value: 5.37 }, pl: { name: 'Polish', l10n: 'Język Polski', value: 7.21 }, pt: { name: 'Portuguese', l10n: 'Português', value: 5.66 }, ro: { name: 'Romanian', l10n: 'Română', value: 6.49 }, ru: { name: 'Russian', l10n: 'Русский', value: 6.06 }, sk: { name: 'Slovak', l10n: 'Slovenčina', value: 6.35 }, sq: { name: 'Albanian', l10n: 'Shqip', value: 6.35 }, sv: { name: 'Swedish', l10n: 'Svenska', value: 5.97 }, tr: { name: 'Turkish', l10n: 'Türkçe', value: 7.22 }, uk: { name: 'Ukrainian', l10n: 'Українська', value: 7.52 }, vi: { name: 'Vietnamese', l10n: 'Tiếng Việt', value: 4.5 }, }; this.content = sample; };
    </script>
    <script>
      var lang = document.getElementById('lang');
      (new Readability()).languages.forEach(el => {
        const opt = document.createElement('option');
        opt.value = el.code;
        opt.text = el.name;
        lang.add(opt);
      });

      function calc () {
        var content = document.getElementById('textin').value,
          language = lang.options[lang.selectedIndex].value,
          evaluator = new Readability(),
          score = document.getElementById('score');

        if (evaluator) {
          evaluator.lang = language;
          score.innerHTML = evaluator.score(content).avg;
          console.log(JSON.stringify(evaluator));
        }
      }
    </script>
  </body>
</html>

