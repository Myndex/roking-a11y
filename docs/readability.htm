<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <title>Roking A11y Readability Evaluator</title>
    <style type="text/css">
      body {
        margin: auto;
        width: 80%;
      }

      blockquote {
        border-left: 0.25rem solid hsl(0, 0%, 90%);
        display: flex;
        margin: 0;
        padding: 1rem;
      }
      blockquote::before {
        background: hsl(0, 0%, 100%);
        color: hsl(0, 100%, 30%);
        content: "⚠";
        font-size: 2rem;
        margin: -0.5rem 0.5rem 0 0;
      }

      button {
        border-radius: 0.25rem;
        font-size: 1.5rem;
        margin: 0.2rem;
      }
      button:not([disabled]) {
        background-color: hsl(204, 100%, 60%);
        border: 1px solid hsl(204, 100%, 30%);
        color: hsl(0, 0%, 5%);
      }

      label {
        font-size: 1.5rem;
        margin-bottom: 0.5rem;
      }

      label,
      textarea {
        display: block;
        line-height: 1.2rem;
        width: 100%;
      }

      textarea {
        border: 1px solid hsl(204, 100%, 30%);
        font-size: 1rem;
        height: 24rem;
      }

      .score {
        background: hsl(204, 100%, 90%);
        border: 1px solid hsl(204, 100%, 30%);
        border-top: none;
        color: hsl(0, 0%, 5%);
        display: block;
        margin-bottom: 1rem;
        padding: 0.25rem 0.15rem;
        width: 100%;
      }
    </style>
  </head>
  <body>
    <main>
      <h1>Readability evaluation using the Läsbarhetsindex</h1>
      <p>
        The Readability utility calculates the Läsbarhetsindex for content.
      </p>
      <blockquote>
        The previous version of the `Readability` object did not account for phrases that
        are not complete sentences, so some measure of caution was advised. For example,
        the phrase "Last Name" would have a Läsbarhetsindex score of 2, but the the phrase
        "Surname" would have a Läsbarhetsindex score of 101, even though its complexity would
        not ordinarily be considered that much greater. To address this, a sample
        must have at least five words to be considered complete.
      </blockquote>
      <p>
        Enter or paste the text to evaluate in the form below.
      </p>
      <p>
        <label for="textin">Text to evaluate</label>
        <textarea id="textin"></textarea>
        <span class="score">
          <span id="score-label">Score</span>: 
          <span aria-labelledby="score-label" id="score" role="status"></span>
        </span>
      </p>
      <p>
        <label for="lang">Language</label>
        <select id="lang"><option value="en">English</option></select>
      </p>
      <p>
        <button type="button" onclick="calc();">Evaluate</button>
      </p>
    </main>
    <script>
function Readability() { Object.defineProperty(this, 'avg', { get: getAvg, enumerable: true, }); Object.defineProperty(this, 'content', { set: setContent, enumerable: true, writeable: true, }); Object.defineProperty(this, 'lang', { get: getLang, set: setLang, enumerable: true, writeable: true, }); Object.defineProperty(this, 'languages', { get: getLangs, enumerable: true, writeable: false, }); Object.defineProperty(this, 'wlong', { get: getLong, set: setLong, enumerable: true, writeable: true, }); this.item = function getItem(index) { return SELF.parsed[index]; }; this.score = function calculate(content) { if (content) { SELF.content = content; } return SELF; }; function getAvg() { if (SELF.parsed && SELF.parsed.length) { const scores = SELF.parsed.map(si => si.score); const sum = scores.reduce((ttl, score) => ttl + score); return Math.round(sum / SELF.parsed.length); } return 0; } function getLang() { return localLang; } function getLangs() { const langs = []; const keys = Object.keys(SIZES).sort(); let i = keys.length - 1; while (i > -1) { const code = keys[i]; const { name } = SIZES[code]; langs.unshift({ code, name }); i -= 1; } return langs; } function getLong() { return localSize; } function isPrimitive(value) { return /^(boolean|number|string)$/.test(typeof value); } function isElement(value) { return value && value.hasChildNodes; } function normalize(phrase) { const els = []; const tags = isElement(phrase) ? (phrase.body || phrase).getElementsByTagName('*') : null; if (isPrimitive(phrase)) { els.push(`${phrase}`); } else if (tags) { for (let c = tags.length - 1; c > -1; c -= 1) { els.unshift(tags.item(c).textContent.replace(/\s+/, ' ')); } } return els; } function parse(phrase) { const bites = phrase.split(' '); const words = bites.length; const longWords = bites.filter(word => word.length > SELF.wlong).length; const sentences = phrase.split(/[:.]/g).filter(el => !!el).length; let pcwords = 0; let pclwords = 0; let score = 0; if (SELF.error) { delete SELF.error; } if (words && sentences && words > 4) { pcwords = words / sentences; pclwords = (longWords * 100) / words; score = Math.round(pcwords + pclwords); } else { const wordCount = `${words} word${words === 1 ? '' : 's'}`; const sentenceCount = `${sentences} sentence${sentences === 1 ? '' : 's'}`; SELF.error = new Error(`Sample size is too small: ${wordCount}, ${sentenceCount}`); } return { longWords, phrase, score, sentences, words, }; } function setContent(data) { SELF.parsed = Array.isArray(data) ? data.map(el => parse(el)) : normalize(data).map(el => parse(el)); } function setLang(bcp47) { const langSubtag = (bcp47 || '').replace(ISO639_1, (match, lang) => lang); if (Object.prototype.hasOwnProperty.call(SIZES, langSubtag)) { localLang = langSubtag; SELF.wlong = Math.round(SIZES[langSubtag].value); } } function setLong(n) { if (n && !Number.isNaN(parseInt(n, 10))) { localSize = parseInt(n, 10); } } const ISO639_1 = /^([a-z]{2})(-[a-z]{2})?$/i; const SELF = this; const SIZES = { ar: { name: 'Arabic', l10n: 'العربية', value: 6.03 }, cs: { name: 'Czech', l10n: 'Český', value: 6.02 }, da: { name: 'Danish', l10n: 'Dansk', value: 5.48 }, de: { name: 'German', l10n: 'Deutsch', value: 6.03 }, el: { name: 'Greek', l10n: 'Ελληνικά', value: 6.47 }, en: { name: 'English', l10n: 'English', value: 6.08 }, es: { name: 'Spanish', l10n: 'Español', value: 5.71 }, et: { name: 'Estonian', l10n: 'Eesti', value: 7.3 }, eu: { name: 'Basque', l10n: 'Euskara', value: 6.51 }, fi: { name: 'Finnish', l10n: 'Suomi', value: 7.55 }, fr: { name: 'French', l10n: 'Français', value: 5.39 }, hr: { name: 'Croatian', l10n: 'Hrvatski Jezik', value: 5.58 }, hu: { name: 'Hungarian', l10n: 'Magyar', value: 6.48 }, is: { name: 'Icelandic', l10n: 'Íslenska', value: 5.97 }, it: { name: 'Italian', l10n: 'Italiano', value: 5.95 }, lt: { name: 'Lithuanian', l10n: 'Lietuvių Kalba', value: 6.85 }, lv: { name: 'Latvian', l10n: 'Latviešu Valoda', value: 7.14 }, nb: { name: 'Norwegian Bokmål', l10n: 'Norsk Bokmål', value: 5.37 }, nl: { name: 'Dutch', l10n: 'Nederlands', value: 6.48 }, nn: { name: 'Norwegian Nynorsk', l10n: 'Norsk Nynorsk', value: 5.37 }, no: { name: 'Norwegian', l10n: 'Norsk', value: 5.37 }, pl: { name: 'Polish', l10n: 'Język Polski', value: 7.21 }, pt: { name: 'Portuguese', l10n: 'Português', value: 5.66 }, ro: { name: 'Romanian', l10n: 'Română', value: 6.49 }, ru: { name: 'Russian', l10n: 'Русский', value: 6.06 }, sk: { name: 'Slovak', l10n: 'Slovenčina', value: 6.35 }, sq: { name: 'Albanian', l10n: 'Shqip', value: 6.35 }, sv: { name: 'Swedish', l10n: 'Svenska', value: 5.97 }, tr: { name: 'Turkish', l10n: 'Türkçe', value: 7.22 }, uk: { name: 'Ukrainian', l10n: 'Українська', value: 7.52 }, vi: { name: 'Vietnamese', l10n: 'Tiếng Việt', value: 4.5 }, }; const n = Object.keys(SIZES).map(el => SIZES[el].value).reduce((ttl, num) => ttl + num); const i = Object.keys(SIZES).length; const avgLength = n / i; let localLang; let localSize = 6; const { lang = (ISO639_1.test(arguments[1]) ? arguments[1] : arguments[2]), size = (arguments[1] && !ISO639_1.test(arguments[1]) ? arguments[1] : null), text = arguments[0], } = (arguments[0] || {}); this.wlong = size || Math.round(avgLength); this.lang = lang; this.content = text;};
    </script>
    <script>
      var lang = document.getElementById('lang');
      (new Readability()).languages.forEach(el => {
        const opt = document.createElement('option');
        opt.value = el.code;
        opt.text = el.name;
        lang.add(opt);
      });

      function calc () {
        var content = document.getElementById('textin').value,
          language = lang.options[lang.selectedIndex].value,
          evaluator = new Readability(),
          score = document.getElementById('score');

        if (evaluator) {
          evaluator.lang = language;
          evaluator.score(content);
          score.innerHTML = evaluator.error ? evaluator.error.message : evaluator.avg;
          console.log(JSON.stringify(evaluator));
        }
      }
    </script>
  </body>
</html>

