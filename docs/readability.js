function Readability() { Object.defineProperty(this, 'LIX', { get: getAvgLix, enumerable: true, }); Object.defineProperty(this, 'OVIX', { get: getAvgOvix, enumerable: true, }); Object.defineProperty(this, 'content', { set: setContent, enumerable: true, writeable: true, }); Object.defineProperty(this, 'lang', { get: getLang, set: setLang, enumerable: true, writeable: true, }); Object.defineProperty(this, 'languages', { get: getLangs, enumerable: true, writeable: false, }); Object.defineProperty(this, 'wlong', { get: getLong, set: setLong, enumerable: true, writeable: true, }); this.item = function getItem(index) { return Me.parsed[index]; }; this.score = function calculate(content) { if (content) { Me.content = content; } return Me; }; function getAvgLix() { if (Me.parsed && Me.parsed.length) { const scores = Me.parsed.map(si => si.lix); const sum = scores.reduce((ttl, score) => ttl + score); return Math.round(sum / Me.parsed.length); } return 0; } function getAvgOvix() { if (Me.parsed && Me.parsed.length) { const scores = Me.parsed.map(si => si.ovix); const sum = scores.reduce((ttl, score) => ttl + score); return Math.round(sum / Me.parsed.length); } return 0; } function getLang() { return localLang; } function getLangs() { const langs = []; const keys = Object.keys(SIZES).sort(); let i = keys.length - 1; while (i > -1) { const code = keys[i]; const { name } = SIZES[code]; langs.unshift({ code, name }); i -= 1; } return langs; } function getLong() { return localSize; } function isPrimitive(value) { return /^(boolean|number|string)$/.test(typeof value); } function isElement(value) { return value && value.hasChildNodes; } function normalize(phrase) { const els = []; const tags = isElement(phrase) ? (phrase.body || phrase).getElementsByTagName('*') : null; if (isPrimitive(phrase)) { els.push(`${phrase}`); } else if (tags) { for (let c = tags.length - 1; c > -1; c -= 1) { els.unshift(tags.item(c).textContent.replace(/\s+/, ' ')); } } return els; } function parse(phrase) { const bites = phrase.split(' '); const words = bites.length; const longWords = bites.filter(word => word.length > Me.wlong).length; const sentences = phrase.split(/[:.]/g).filter(el => !!el).length; const unique = bites.filter((v, i, a) => a.indexOf(v) === i).length; const ovixNum = Math.log(words); const ovixDenom = Math.log(2 - Math.log(unique) / Math.log(words)); let pcwords = 0; let pclwords = 0; let lix = 0; let ovix = 0; if (Me.error) { Me.error = null; } if (words && sentences && words > 4) { pcwords = words / sentences; pclwords = (longWords * 100) / words; lix = Math.round(pcwords + pclwords); ovix = Number((ovixDenom ? ovixNum / ovixDenom : 0).toFixed(2)); } else { const wordCount = `${words} word${words === 1 ? '' : 's'}`; const sentenceCount = `${sentences} sentence${sentences === 1 ? '' : 's'}`; Me.error = new Error(`Sample size is too small: ${wordCount}, ${sentenceCount}`); } return { longWords, phrase, lix, ovix, sentences, words, }; } function setContent(data) { Me.error = null; Me.parsed = Array.isArray(data) ? data.map(el => parse(el)) : normalize(data).map(el => parse(el)); } function setLang(bcp47) { const langSubtag = (bcp47 || '').replace(ISO639_1, (match, lang) => lang); if (Object.prototype.hasOwnProperty.call(SIZES, langSubtag)) { localLang = langSubtag; Me.wlong = Math.round(SIZES[langSubtag].value); } } function setLong(n) { if (n && !Number.isNaN(parseInt(n, 10))) { localSize = parseInt(n, 10); } } const ISO639_1 = /^([a-z]{2})(-[a-z]{2})?$/i; const Me = this; const SIZES = { ar: { name: 'Arabic', l10n: 'العربية', value: 6.03 }, cs: { name: 'Czech', l10n: 'Český', value: 6.02 }, da: { name: 'Danish', l10n: 'Dansk', value: 5.48 }, de: { name: 'German', l10n: 'Deutsch', value: 6.03 }, el: { name: 'Greek', l10n: 'Ελληνικά', value: 6.47 }, en: { name: 'English', l10n: 'English', value: 6.08 }, es: { name: 'Spanish', l10n: 'Español', value: 5.71 }, et: { name: 'Estonian', l10n: 'Eesti', value: 7.3 }, eu: { name: 'Basque', l10n: 'Euskara', value: 6.51 }, fi: { name: 'Finnish', l10n: 'Suomi', value: 7.55 }, fr: { name: 'French', l10n: 'Français', value: 5.39 }, hr: { name: 'Croatian', l10n: 'Hrvatski Jezik', value: 5.58 }, hu: { name: 'Hungarian', l10n: 'Magyar', value: 6.48 }, is: { name: 'Icelandic', l10n: 'Íslenska', value: 5.97 }, it: { name: 'Italian', l10n: 'Italiano', value: 5.95 }, lt: { name: 'Lithuanian', l10n: 'Lietuvių Kalba', value: 6.85 }, lv: { name: 'Latvian', l10n: 'Latviešu Valoda', value: 7.14 }, nb: { name: 'Norwegian Bokmål', l10n: 'Norsk Bokmål', value: 5.37 }, nl: { name: 'Dutch', l10n: 'Nederlands', value: 6.48 }, nn: { name: 'Norwegian Nynorsk', l10n: 'Norsk Nynorsk', value: 5.37 }, no: { name: 'Norwegian', l10n: 'Norsk', value: 5.37 }, pl: { name: 'Polish', l10n: 'Język Polski', value: 7.21 }, pt: { name: 'Portuguese', l10n: 'Português', value: 5.66 }, ro: { name: 'Romanian', l10n: 'Română', value: 6.49 }, ru: { name: 'Russian', l10n: 'Русский', value: 6.06 }, sk: { name: 'Slovak', l10n: 'Slovenčina', value: 6.35 }, sq: { name: 'Albanian', l10n: 'Shqip', value: 6.35 }, sv: { name: 'Swedish', l10n: 'Svenska', value: 5.97 }, tr: { name: 'Turkish', l10n: 'Türkçe', value: 7.22 }, uk: { name: 'Ukrainian', l10n: 'Українська', value: 7.52 }, vi: { name: 'Vietnamese', l10n: 'Tiếng Việt', value: 4.5 }, }; const n = Object.keys(SIZES).map(el => SIZES[el].value).reduce((ttl, num) => ttl + num); const i = Object.keys(SIZES).length; const avgLength = n / i; let localLang; let localSize = 6; const { lang = (ISO639_1.test(arguments[1]) ? arguments[1] : arguments[2]), size = (arguments[1] && !ISO639_1.test(arguments[1]) ? arguments[1] : null), text = arguments[0], } = (arguments[0] || {}); this.wlong = size || Math.round(avgLength); this.lang = lang; this.content = text;};
